{
  "reference": {
    "integer": {
      "type": "number"
    },
    "float": {
      "type": "number"
    },
    "percent": {
      "type": "number",
      "code": "percent",
      "params": [
        0
      ]
    },
    "string": {
      "type": "string"
    },
    "regex": {
      "type": "pattern"
    },
    "true": {
      "type": "boolean"
    },
    "false": {
      "type": "boolean"
    },
    "null": {
      "type": "null"
    },

    "ident": {
      "type": "ident"
    },

    "?": {
      "type": "var"
    },

    "DotRoot-><.>": {
      "code": "literal",
      "params": [
        0
      ]
    },

    "Ref-><@> <ident>": {
      "type": "mixed",
      "code": "varget",
      "params": [
        {
          "child": 2,
          "as": "id"
        }
      ]
    },
    "RefIndex-><@> <integer>": {
      "type": "mixed",
      "code": "varget",
      "params": [
        {
          "child": 2,
          "as": "id"
        }
      ]
    },
    "RefIndex-><?>": {
      "type": "mixed",
      "code": "varget",
      "params": [
        1
      ]
    },
    "InExpr-><(> Assignable <)>": {
      "code": 1
    },

    "RangeUnit-><integer>": {
      "code": 0
    },
    "RangeUnit->RefIndex": {
      "code": 0
    },
    "RangeUnit->InExpr": {
      "code": 0
    },
    "Range->RangeUnit <..> RangeUnit": {
      "type": "keyrange"
    },

    "KeyFilter->KeyFilter <,> RangeOp": {
      "type": "list"
    },
    "KeyFilter->RangeUnit <,> RangeOp": {
      "type": "list"
    },
    "KeyFilter->Range": {
      "type": "list"
    },

    "Key-><ident>": {
      "type": "string"
    },
    "Key-><string>": {
      "type": "string"
    },

    "DotKey-><.> Key": {
      "type": "keyaccess"
    },
    "BraceKey-><[> Key <]>": {
      "type": "keyaccess"
    },

    "DotFilter-><.> <*>": {
      "type": "keyfilter"
    },
    "BraceFilter-><[> <]>": {
      "type": "keyfilter"
    },
    "BraceFilter-><[> <*> <]>": {
      "type": "keyfilter"
    },
    "BraceFilter-><[> KeyFilter <]>": {
      "type": "keyfilter"
    },

    "PathRoot-><ident>": {
      "type": "keyaccess"
    },
    "PathRoot->Root": {
      "type": "keyaccess"
    },
    "PathRoot->Ref": {
      "type": "keyaccess"
    },
    "PathRoot->RefIndex": {
      "type": "keyaccess"
    },
    "PathRoot->DotRoot BraceKey": {
      "type": "keyaccess"
    },
    "PathRoot->InExpr RootKey": {
      "type": "keyaccess"
    },

    "PathRoot->DotRoot BraceFilter": {
      "type": "keyfilter"
    },
    "PathRoot->InExpr RootFilter": {
      "type": "keyfilter"
    },

    "DotKeyAccess->PathAccess DotKey": {
      "type": "keyaccess"
    },
    "BraceKeyAccess->PathAccess BraceKey": {
      "type": "keyaccess"
    },

    "DotAccess->PathAccess DotFilter": {
      "type": "keyfilter"
    },
    "BraceAccess->PathAccess BraceFilter": {
      "type": "keyfilter"
    },

    "Path->PathAccess": {
      "type": "mixed"
    },

    "Num-><integer>": {
      "code": 0
    },
    "Num-><float>": {
      "code": 0
    },
    "Num-><percent>": {
      "code": 0
    },

    "Negative-><-> Num": {
      "type": "number",
      "code": "negative",
      "params": [
        2
      ]
    },
    "Positive-><+> Num": {
      "code": 1
    },

    "Variant->Path": {
      "code": 0
    },
    "Variant->Call": {
      "code": 0
    },
    "Variant->InExpr": {
      "code": 0
    },

    "Params->Params <,> Assignable": {
      "type": "list"
    },

    "Call-><ident> <(> Params <)>": {
      "type": "mixed"
    },

    "Numeric->Num": {
      "code": 0
    },
    "Numeric->Negative": {
      "code": 0
    },
    "Numeric->Positive": {
      "code": 0
    },

    "FactorOp->Numeric": {
      "code": 0
    },
    "FactorOp->Variant": {
      "type": "number",
      "code": "numberify",
      "params": [
        1
      ]
    },

    "Factor->Mul": {
      "code": 0
    },
    "Factor->Div": {
      "code": 0
    },
    "Factor->Mode": {
      "code": 0
    },
    "Factor->Numeric": {
      "code": 0
    },
    "Factor->Variant": {
      "code": 0
    },

    "Mod->Factor <%> FactorOp": {
      "type": "number",
      "code": "binary",
      "params": [
        {
          "child": 1,
          "cast": "number"
        },
        2,
        3
      ]
    },

    "Div->Factor </> FactorOp": {
      "type": "number",
      "code": "binary",
      "params": [
        {
          "child": 1,
          "cast": "number"
        },
        2,
        3
      ]
    },

    "Mul->Factor <*> FactorOp": {
      "type": "number",
      "code": "binary",
      "params": [
        {
          "child": 1,
          "cast": "number"
        },
        2,
        3
      ]
    },

    "Term->Factor": {
      "code": 0
    },
    "Term->Add": {
      "code": 0
    },
    "Term->Sub": {
      "code": 0
    },

    "Add->Term <+> Factor": {
      "type": "number",
      "code": "binary",
      "params": [
        {
          "child": 1,
          "cast": "number"
        },
        2,
        {
          "child": 3,
          "cast": "number"
        }
      ]
    },

    "Sub->Term <-> Factor": {
      "type": "number",
      "code": "binary",
      "params": [
        {
          "child": 1,
          "cast": "number"
        },
        2,
        {
          "child": 3,
          "cast": "number"
        }
      ]
    },

    "Concat->Concat <+> Scalar": {
      "type": "string",
      "code": "binary",
      "params": [
        {
          "child": 1
        },
        2,
        {
          "child": 3,
          "cast": "string"
        }
      ]
    },
    "Concat-><string> <+> <string>": {
      "type": "string",
      "code": "binary",
      "params": [
        1,
        2,
        3
      ]
    },
    "Concat->Term <+> <string>": {
      "type": "string",
      "code": "binary",
      "params": [
        {
          "child": 1,
          "cast": "string"
        },
        2,
        3
      ]
    },
    "Concat-><string> <+> Term": {
      "type": "string",
      "code": "binary",
      "params": [
        1,
        2,
        3
      ]
    },

    "Scalar->Term": {
      "code": 0
    },
    "Scalar->Concat": {
      "code": 0
    },
    "Scalar-><string>": {
      "code": 0
    },

    "Lt->Scalar <<> Scalar": {
      "type": "boolean",
      "code": "binary",
      "params": [
        1,
        2,
        3
      ]
    },
    "Lte->Scalar <<=> Scalar": {
      "type": "boolean",
      "code": "binary",
      "params": [
        1,
        2,
        3
      ]
    },
    "Gt->Scalar <>> Scalar": {
      "type": "boolean",
      "code": "binary",
      "params": [
        1,
        2,
        3
      ]
    },
    "Gte->Scalar <>=> Scalar": {
      "type": "boolean",
      "code": "binary",
      "params": [
        1,
        2,
        3
      ]
    },

    "Prop-><ident> <:> Assignable": {
      "type": "hash"
    },

    "Props->Props <,> Prop": {
      "type": "hashlist"
    },

    "Object-><{> Props <}>": {
      "type": "object"
    },

    "Array-><[> Params <]>": {
      "type": "list"
    },

    "Compound->Scalar": {
      "code": 0
    },
    "Compound->Object": {
      "code": 0
    },
    "Compound->Array": {
      "code": 0
    },
    "Compound->Boolean": {
      "code": 0
    },
    "Compound-><null>": {
      "code": 0
    },
    "Compound->Not": {
      "code": 0
    },

    "Not-><!> Compound": {
      "type": "boolean",
      "code": "not",
      "params": [
        2
      ]
    },

    "SNeq->Compound <!==> Compound": {
      "type": "boolean",
      "code": "binary",
      "params": [
        {
          "child": 1,
          "cast": "boolean"
        },
        {
          "child": 2,
          "use": "rule"
        },
        {
          "child": 3,
          "cast": "boolean"
        }
      ]
    },
    "Neq->Compound <!=> Compound": {
      "type": "boolean",
      "code": "binary",
      "params": [
        {
          "child": 1,
          "cast": "boolean"
        },
        2,
        {
          "child": 3,
          "cast": "boolean"
        }
      ]
    },
    "Seq->Compound <===> Compound": {
      "type": "boolean",
      "code": "binary",
      "params": [
        {
          "child": 1,
          "cast": "boolean"
        },
        2,
        {
          "child": 3,
          "cast": "boolean"
        }
      ]
    },
    "Eq->Compound <==> Compound": {
      "type": "boolean",
      "code": "binary",
      "params": [
        {
          "child": 1,
          "cast": "boolean"
        },
        2,
        {
          "child": 3,
          "cast": "boolean"
        }
      ]
    },
    "MatchOp-><string>": {
      "code": 0
    },
    "MatchOp-><regex>": {
      "code": 0
    },
    "Match->Scalar <=~> MatchOp": {
      "type": "boolean",
      "code": "match",
      "params": [
        1,
        3
      ]
    },

    "Comparable->Compound": {
      "code": 0
    },
    "Comparable->Match": {
      "code": 0
    },
    "Comparable->Eq": {
      "code": 0
    },
    "Comparable->Neq": {
      "code": 0
    },
    "Comparable->SNeq": {
      "code": 0
    },
    "Comparable->Seq": {
      "code": 0
    },
    "Comparable->Gt": {
      "code": 0
    },
    "Comparable->Gte": {
      "code": 0
    },
    "Comparable->Lt": {
      "code": 0
    },
    "Comparable->Lte": {
      "code": 0
    },

    "Logical->Comparable": {
      "code": 0
    },
    "Logical->Or": {
      "code": 0
    },
    "Logical->And": {
      "code": 0
    },

    "Or->Logical <||> Comparable": {
      "type": "boolean",
      "code": "binary",
      "params": [
        1,
        2,
        {
          "child": 3,
          "cast": "boolean"
        }
      ]
    },
    "And->Logical <&&> Comparable": {
      "type": "boolean",
      "code": "binary",
      "params": [
        1,
        2,
        {
          "child": 3,
          "cast": "boolean"
        }
      ]
    },

    "Unset-><delete> Path": {
      "type": "boolean"
    },
    "TernCond->Logical <?>": {
      "code": 0
    },
    "Assignable->Assign": {
      "code": 0
    },
    "Assignable->Logical": {
      "code": 0
    },
    "Assignable->Cond": {
      "code": 0
    },
    "Cond->TernCond Assignable <:> Assignable": {
      "type": "mixed",
      "code": "ternaryIf",
      "params": [
        {
          "child": 1,
          "cast": "boolean"
        },
        2,
        4
      ]
    },

    "Assign->Path <=> Assignable": {
      "type": "mixed"
    },

    "Expr->Logical": {
      "code": 0
    },
    "Expr->Cond": {
      "code": 0
    },

    "Var-><ident> <from> Path": {
      "type": "mixed",
      "code": "varset",
      "params": [
        {
          "child": 1,
          "as": "id"
        },
        {
          "child": 3
        }
      ]
    },
    "Vars->Var": {
      "code": 0
    },
    "Vars->Vars <;> Var": {
      "code": "combine",
      "params": [
        1,
        2
      ]
    },

    "Query->Expr <$>": {
      "type": "mixed",
      "code": "returnone",
      "params": [
        1
      ]
    },
    "Query->Vars <;> Expr <$>": {
      "type": "mixed",
      "code": "return",
      "params": [
        3,
        1
      ]
    }
  },
  "preprocess": {
    "getter": {
      "jsonpath": "pathgetter"
    }
  },
  "typecast": {
    "number": {
      "*": "numberify",
      "boolean": "ifnumberify"
    },
    "string": {
      "*": "stringify"
    },
    "boolean": {
      "*": "booleanify"
    }
  },
  "template": {
    "literal": {
      "return": [0]
    },
    "symbolize": {
      "symbols": 1,
      "return": [0],
      "body": [
        "$1",
        0, " = ", 1, ";"
      ]
    },
    "percent": {
      "body": [
        "$0"
      ],
      "return": [
        "(", 0, " / 100)"
      ]
    },
    "numberify": {
      "body": [
        "$0"
      ],
      "return": [
        "(parseFloat(", 0, ") || 0)"
      ]
    },
    "ifnumberify": {
      "body": [
        "$0"
      ],
      "return": [
        "(", 0, " ? 1 : 0)"
      ]
    },
    "booleanify": {
      "body": [
        "$0"
      ],
      "return": [
        "!!(", 0, ")"
      ]
    },
    "stringify": {
      "body": [
        "$0"
      ],
      "return": [
        "String(", 0, ")"
      ]
    },
    "varset": {
      "symbols": 1,
      "return": [
        0
      ],
      "body": [
        "$1",
        "$2",
        0, " = vars[", 1, "] = ", 2, ";"
      ]
    },
    "varget": {
      "symbols": 1,
      "return": [
        0
      ],
      "body": [
        "$1",
        0, " = ", 1, " in vars ? vars[", 1, "] : undefined;"
      ]
    },
    "pathgetter": {
      "symbols": 1,
      "return": [0],
      "body": [
        "$1",
        0, " = helper_path(", 1, "[0], ", 1, "[1]);"
      ]
    },
    "define": {
      "body": [
        "$0",
        "$1",
        0, " = ", 1, ";"
      ],
      "return": [
        0
      ]
    },
    "combine": {
      "body": [
        "$0",
        "$1"
      ],
      "return": [
        2
      ]
    },
    "negative": {
      "body": [
        "$0"
      ],
      "return": [
        "(0 - ", 0, ")"
      ]
    },
    "not": {
      "body": [
        "$0"
      ],
      "return": [
        "!(", 0, ")"
      ]
    },
    "binary": {
      "body": [
        "$0",
        "$2"
      ],
      "return": [
        0, " ", 1, " ", 2
      ]
    },
    "match": {
      "symbols": 1,
      "return": [0],
      "body": [
        "$1",
        "$2",
        0, " = typeof ", 1, " === 'string'\n",
          "? String(", 2, ").indexOf(", 1, ") !== -1\n",
          ": (", 1, ").test(", 2, ");"
      ]
    },
    "ternaryIf": {
      "symbols": 1,
      "return": [0],
      "body": [
        "$1",
        "if (", 1, ") {\n",
          "$2",
          0, " = ", 2, ";\n",
        "// else ----------------- \n",
        "} else {\n",
          "$3",
          0, " = ", 3, ";\n",
        "}"
      ]
    },
    "return": {
      "body": [
        "$1",
        "$0",
        "return ", 0, ";"
      ]
    },
    "returnone": {
      "body": [
        "$0",
        "return ", 0, ";"
      ]
    }
  }
}

