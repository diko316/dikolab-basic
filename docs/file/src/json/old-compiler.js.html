<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/json/old-compiler.js | @dikotech/basic</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Basic Javascript helpers"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="@dikotech/basic"><meta property="twitter:description" content="Basic Javascript helpers"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/diko316/dikotech-basic"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#array">array</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-listPadEnd">listPadEnd</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-listPadStart">listPadStart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Iteratable">Iteratable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IteratableObject">IteratableObject</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#json-helper">json/helper</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-access">access</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-JsonHelperAccessPath">JsonHelperAccessPath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-JsonHelperAccessPathFill">JsonHelperAccessPathFill</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-JsonHelperAccessPathType">JsonHelperAccessPathType</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#lifecycle">lifecycle</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-destructor">destructor</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#native">native</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-array">array</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-bigint">bigint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-boolean">boolean</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-date">date</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-iteratable">iteratable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-method">method</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-number">number</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-numeric">numeric</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-object">object</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-promise">promise</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-regexp">regexp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-scalar">scalar</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-signature">signature</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-string">string</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-symbol">symbol</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#number">number</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-numberify">numberify</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#object">object</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-assign">assign</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-each">each</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-contains">contains</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#string">string</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-padEnd">padEnd</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-padStart">padStart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-repeat">repeat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-trim">trim</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-trimEnd">trimEnd</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-trimStart">trimStart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-stringify">stringify</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#unicode">unicode</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/unicode/Utf.js~Utf.html">Utf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-codepoints2Utf">codepoints2Utf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unicodeCount">unicodeCount</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unicodify">unicodify</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-codePoint2string">codePoint2string</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-eachUnicode">eachUnicode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-string2codePoints">string2codePoints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-string2unicodes">string2unicodes</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/json/old-compiler.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { parse } from &quot;./parser&quot;;

import {
  EMPTY_FUNCTION,
  TYPE_STRING,
  TYPE_NUMBER
} from &quot;../native/constants&quot;;

import { quoteEscapify } from &quot;../string/format&quot;;

import COMPILER_REFERENCE from &quot;./compiler-reference.json&quot;;

const TEMPLATES = COMPILER_REFERENCE.template;
const COMPILE_ACCEPT_RPN = 1;
const COMPILE_CREATE_CODEREF = 2;
const COMPILE_INSERT_CODEREF = 3;
const COMPILE_PROCESS_CODEREF = 4;

const SYMBOL_PREFIX = &quot;v&quot;;
const REF_PREFIX = &quot;r&quot;;
const CAST_REFERENCE = COMPILER_REFERENCE.typecast;
const CAST_PARAMS = [
  {
    source: 0
  }
];

function createCode(settings, template, args) {
  let symbol = &quot;&quot;;
  let code = &quot;&quot;;
  let codes;
  let codeLength;
  let process;
  let c;
  let length;
  let value;

  // generate code
  process = template.body;
  if (process) {
    codes = [];
    codeLength = 0;
    c = 0;
    length = process.length;
    for (; length--; c++) {
      value = process[c];
      value = value in args ? args[value] : value;
      if (value) {
        codes[codeLength++] = value;
      }
    }
    if (codeLength) {
      code = codes.join(&quot;&quot;) + &quot;\n&quot;;
    }
  }

  // generate return reference
  process = template.return;
  if (process) {
    codes = [];
    codeLength = 0;
    c = 0;
    length = process.length;
    for (; length--; c++) {
      value = process[c];
      value = value in args ? args[value] : value;
      if (value) {
        codes[codeLength++] = value;
      }
    }
    if (codeLength) {
      symbol = codes.join(&quot;&quot;);
    }
  }

  return [symbol, code];
}

function createCodeParams(settings, symbolCount, params, nodes) {
  const symbolPrefix = SYMBOL_PREFIX;
  const refPrefix = REF_PREFIX;
  const templates = TEMPLATES;
  const castReference = CAST_REFERENCE;
  const typeNumber = TYPE_NUMBER;
  const castParams = CAST_PARAMS;
  const symbols = settings.symbols;
  const vars = settings.reference;
  const args = {};

  let symbolLength = symbols.length;
  let key;
  let argsLength = 0;
  let codeLength = 0;
  let c;
  let length;
  let param;
  let symbol;
  let node;
  let code;
  let cast;
  let type;
  let codes;
  let reference;
  let source;
  let paramType;
  let codeKey;
  let ref;
  let resolve;

  // generate symbols
  if (symbolCount) {
    length = symbolCount;
    for (; length--;) {
      symbol = `${symbolPrefix}${symbolLength + 1}`;
      symbols[symbolLength++] = symbol;
      key = argsLength++;
      args[`$${key}`] = &quot;&quot;;
      args[key] = symbol;
    }
  }

  // generate parameters
  c = 0;
  length = params.length;
  for (; length--; c++) {
    param = source = params[c];
    paramType = cast = null;
    if (typeof param !== typeNumber) {
      source = param.source;
      paramType = param.as;
      cast = param.cast;
      resolve = param.resolve;
    }
    key = argsLength++;
    codeKey = `$${key}`;

    // find parameter source
    if ((source === 0 || source) &amp;&amp; source in nodes) {
      node = nodes[source];
    }
    // undefined fill in
    else {
      args[codeKey] = &quot;&quot;;
      args[key] = &quot;undefined /* child not found */&quot;;
      continue;
    }

    type = node.type;

    // finalize reference to use
    ref = node.ref;

    switch (paramType) {
    case &quot;autofill&quot;:
      ref = ++settings.vars;

    // falls through
    case &quot;id&quot;:
      ref = String(ref) || &quot;undefined&quot;;
      symbol = quoteEscapify(ref);
      ref = ref in vars
        ? vars[ref]
        : (vars[ref] = `&quot;${symbol}&quot;`);
      break;
    }

    // create initial code
    codeLength = 0;
    codes = [];
    code = node.code;
    if (code) {
      codes[codeLength++] = code;
    }

    // resolve or typecast
    if (resolve || cast) {
      // typecast if needed
      reference = cast &amp;&amp; cast !== type &amp;&amp;
        cast in castReference &amp;&amp;
        castReference[cast];
    }

    // typecast if needed
    reference = cast &amp;&amp; cast !== type &amp;&amp;
      cast in castReference &amp;&amp;
      castReference[cast];

    if (reference) {
      // finalize type if type not found
      if (!(type in reference)) {
        // use wildcard
        type = &quot;*&quot;;
      }

      // type cast if found
      if (type in reference) {
        cast = createCode(
          settings,
          templates[
            reference[type]
          ],
          createCodeParams(
            settings,
            0,
            castParams,
            [node]
          )
        );

        // replace!
        symbol = cast[0];
        if (symbol) {
          ref = symbol;
        }

        // add code
        code = cast[1];
        if (code) {
          codes[codeLength++] = code;
        }
      }
    }

    args[codeKey] = codeLength ? codes.join(&quot;&quot;) : &quot;&quot;;
    args[key] = ref;
  }

  return args;
}

export function compile(subject, params) {
  const emptyFunction = EMPTY_FUNCTION;
  const compilerReference = COMPILER_REFERENCE;
  const templates = COMPILER_REFERENCE.template;
  const definitions = compilerReference.reference;

  const actionAcceptRpn = COMPILE_ACCEPT_RPN;
  const actionCreateCodeRef = COMPILE_CREATE_CODEREF;
  const actionInsertCodeRef = COMPILE_INSERT_CODEREF;
  const actionProcessCodeRef = COMPILE_PROCESS_CODEREF;

  const stack = [];
  const symbols = [];
  const settings = {
    vars: 0,
    reference: {},
    symbols: symbols
  };

  let action = actionAcceptRpn;
  let rpnIndex = 0;
  let rpn = null;
  let rpnCount;
  let unprocessed;
  let codeRef;
  let code;
  let reduce;
  let children;
  let child;
  let childIndex;
  let definition;
  let ruleId;
  let symbol;
  let template;
  let templateParams;
  let type;
  let stackLength = 0;

  let limit = 50;

  if (typeof subject !== TYPE_STRING) {
    return emptyFunction;
  }

  rpn = parse(subject);

  if (!rpn) {
    return emptyFunction;
  }

  rpnCount = rpn.length;

  for (; rpnCount;) {
    // get one rpn item
    if (action === actionAcceptRpn) {
      rpnCount--;
      unprocessed = rpn[rpnIndex++];
      action = actionCreateCodeRef;
    }

    // create coderef
    if (action === actionCreateCodeRef) {
      // reduce
      reduce = unprocessed.reduce;
      ruleId = unprocessed.ruleId;
      stackLength -= reduce;
      children = reduce
        ? stack.splice(stackLength, reduce)
        : [];

      codeRef = {
        rule: ruleId,
        type: null,
        ref: unprocessed.value || &quot;undefined&quot;,
        code: &quot;&quot;
      };

      // process by definition
      definition = null;

      if (ruleId in definitions) {
        definition = definitions[ruleId];
        action = actionProcessCodeRef;
      }
      else {
        // console.log(&quot;no definition! &quot;, ruleId);
        action = actionInsertCodeRef;
      }
      // console.log(&quot;rule &quot;, ruleId, &quot; definition: &quot;, definition);
    }

    // process codeRef
    if (action === actionProcessCodeRef) {
      type = definition.type;
      code = unprocessed.value;
      symbol = &quot;&quot;;

      // process child reuse
      if (&quot;useChild&quot; in definition) {
        childIndex = definition.useChild;
        if (!(childIndex in children)) {
          throw new Error(`Invalid child to reuse ${childIndex}`);
        }
        child = children[childIndex];
        code = child.code;
        type = child.type;
        symbol = child.ref;
      }
      // process code
      else if (&quot;code&quot; in definition) {
        // set generated code
        template = templates[definition.code];
        templateParams = [
          {
            type,
            code: &quot;&quot;,
            ref: code
          }
        ];
        templateParams.push.apply(templateParams, children);
        code = createCode(
          settings,
          template,
          createCodeParams(
            settings,
            template.symbols,
            definition.params,
            templateParams
          )
        );

        symbol = code[0];
        code = code[1];
      }

      codeRef.type = type;
      codeRef.code = code || &quot;&quot;;
      codeRef.ref = symbol || &quot;&quot;;

      action = actionInsertCodeRef;
    }

    // insert codeRef
    if (action === actionInsertCodeRef) {
      stack[stackLength++] = codeRef;
      action = actionAcceptRpn;
      console.log(&quot;ref &quot;, codeRef);
    }

    if (!--limit) {
      console.log(&quot;reached limit!&quot;);
      break;
    }
  }

  // console.log(JSON.stringify(stack, null, 3));

  if (stackLength) {
    console.log(&quot;code:\n\n&quot; + stack[0].code);
  }

  return emptyFunction;
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
